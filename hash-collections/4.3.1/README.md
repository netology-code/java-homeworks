## Задача 1 (HashMap). Телефонный справочник

### Описание
Эта задача про телефонный справочник с поддержкой групп контактов. Один контакт может входить в несколько групп.
Например, если вы работаете со своим другом, то он будет в группах "Друзья" и "Работа".
У пользователя должна быть возможность создания групп и контактов, добавления одного контакта в несколько групп.

### Функционал программы
1. Создание группы;
2. Создание контакта;
3. Добавление контакта в разные группы;
4. Вывод групп с контактами.

### Пример
```
Программа справочник
Введите название группы контактов:
Семья <enter>
Создать еще одну группу (введите название или введите нет)?
Друзья <enter>
Создать еще одну группу (введите название или введите нет)?
нет <enter>
Создать контакт (введите наименование и его номер или введите нет)?
John Smith +7(911)111-11-11
Укажите группы контакта через пробел
Семья
Создать контакт (введите наименование или введите нет)?
нет <enter>
Группы в справочнике:
- Семья:
      Имя: John Smith, Телефон: +7(911)111-11-11 
```

### Реализация
1. Создадим класс `PhoneContacts`, в котором будем хранить все созданные группы.
2. В классе `PhoneContacts` создадим HashMap: ключом для этой коллекции будет название группы, а значением — коллекция контактов.
3. Создадим класс `Contact` c полями: имя и номер телефона (при необходимости переоределим `hashCode, equals, toString`).
4. Создадим методы для добавления группы и контакта в группы в классе `PhoneContacts`.
5. В цикле создадим новые группы.
6. В другом цикле создадим новые контакты и добавим их в группы.
7. Выведем все группы с контактами.
8. Для демонстрации работы программы в коде создадим несколько контактов и добавим их в несколько групп.

> Так как со временем наши задачи становятся всё объёмнее, пора бы задуматься об архитектуре нашего приложения:
> как можно больше логики выносите из функции main в небольшие, узкоспециализированные функции! Так будет намного легче писать/читать/поддерживать код.

### Дополнительное задание
Необходимо вывести все контакты в отсортированном виде (по имени).
Для того чтобы наш список контактов был отсортирован, необходимо, чтобы класс `Contact` реализовывал интерфейс `Comparable`.

### Реализация
Создадим `List<Contact>`, который будем всегда поддерживать отсортированным.
Для этого перед добавлением очередного элемента в список будем находить для него правильную позицию, при которой имя предыдущего будет меньше, а имя следующего больше. 
Так как список у нас все время будет отсортированный, то эффективнее всего искать позицию для элемента с помощью [бинарного поиска](https://ru.wikipedia.org/wiki/Двоичный_поиск). 

В  Java этот алгоритм уже реализован в `Collections.binarySearch(list, key)`: 
* если элемент содержится в списке, то метод вернет его позицию, 
* если элемента в коллекции нет, то метод вернет отрицательное значение рассчитанное по формуле: 
`-index - 1`, значит чтобы найти место вставки, можно взять абослютное значение и вычесть из него единицу: `Math.abs(value) - 1`. 
Можно воспользоваться им или написать свою реализацию.

> На следующих лекциях мы будем рассматривать структуры данных, которые "из коробки" позволяют хранить данные отсортированными. Например, класс TreeSet.
