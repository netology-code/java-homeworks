# Домашнее задание к занятию 3.2. Массивы многомерные
## Задача 2. Морской бой

### Описание
Вы пишете игру "морской бой" в минимальном варианте, где стреляете только вы.
На входе - двумерный массив 10 на 10, заполненный числами.

Возможные числа: 0 ("пустое поле"), 1 ("есть корабль"), 2 ("корабль застрелен"), 3 ("промах").
При этом "корабли" занимают не более 10 клеток. Расстоянием между кораблями и "палубностью" кораблей мы пренебрегаем.
Пользователь вводит координаты поля, в которое стреляет. 

В зависимости от результата "выстрела" программа выдает ему ответ - "попал"/"не попал".
После попадания во все корабли, либо по истечению 30 ходов, игра считается законченной.
Если за время игры были застрелены все 10 клеток с кораблями, то игра выиграна.

### Пример реализации
1. Для решения данной задачи нужно создать двумерный массив 10x10:
``` 
0 - "пустое поле"
1 - "есть корабль"
``` 
Создадим SIZE, для сохранения размерности массива:
```java
// определяем размерность массива
int SIZE = 10;
// Создаем двумерный массив
int warField[][]= new int[SIZE][SIZE];
``` 

Также во время игры ячейки матрицы могут изменяться, получая следующие значения:
``` 
2 - "корабль застрелен"
3 - "промах"
``` 

Для хранения состояния клетки создадим константы и дальше в коде будем использовать их:
```java
int EMPTY = 0;
int SHIP = 1;
int DEAD = 2;
int MISS = 3;
```

2. В условии задачи дано, что максимальное число кораблей 10.
Объявим переменную maxCount для хранения максимального числа кораблей.
```java
int MAX_COUNT = 10;
``` 
Теперь, когда у нас есть поле, разместим на нем корабли.

3. Разместим корабли в случайном порядке на поле (матрица warField):
Для этого нужны случайные значения в диапазоне от 0 до 9 для координат ячеек.

Обозначим значения первой размерности shipPlace1, а  второй размерности - shipPlace2.
В таком случае у нас случайные координаты ячеек для кораблей примут следующий вид:
```java
Random random = new Random();
for (int i = 0; i < MAX_COUNT; i++) {
  int shipPlace1 = random.nextInt(SIZE);
  int shipPlace2 = random.nextInt(SIZE);
  
  warField[shipPlace1][shipPlace2] = SHIP;
}
``` 

Так как координаты могут повторяться, внесем некоторые изменения в нашем цикле. Добавим проверку наличия корабля в указанной ячейке, обеспечив при этом повторный круг для данного корабля.

```java
Random random = new Random();
for (int i = 0; i< MAX_COUNT; i++) {
  int shipPlace1 = random.nextInt(SIZE);
  int shipPlace2 = random.nextInt(SIZE);
  
  if (warField[shipPlace1][shipPlace2] == SHIP){
    // повторная генерация положения для данного корабля
    i--;
  }
  
  warField[shipPlace1][shipPlace2] = SHIP;
}
``` 

4.И так у нас есть поле с кораблями, выводим его на экран:

```java 
// выводим массив на экран
// Цикл по первой размерности выводит строки
for (int i = 0; i< SIZE; i++) {
  // Цикл по второй размерности выводит колонки - вывод одной строки
  for (int j = 0; j< SIZE; j++) {
    // Используем оператор print - без перехода на следующую строку
    System.out.print(warField[i][j]);
  }
  // Переход на следующую строку
  System.out.println();
}
``` 

5. Далее необходимо ввести две координаты с клавиатуры с помощью `Scanner.nextInt()`. В зависимости от значения в матрице выводить соответсвующее сообщение.

6. После каждого хода выводить обновленную матрицу на экран, а также проверять, не превышено ли максимальное количество шагов и остались ли ещё "не подбитые" корабли в игре.
